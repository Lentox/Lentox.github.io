<!DOCTYPE html>
<html>
<head>
  <title>Hexagon Border</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden; /* Entfernt das Scrollen */
    }
  </style>
</head>
<body>
<canvas id="hexagonCanvas"></canvas>
<script>
  var canvas = document.getElementById("hexagonCanvas");
  var context = canvas.getContext("2d");

  var hexagonRadius = 30;
  var hexagonWidth = Math.sqrt(3) * hexagonRadius;
  var hexagonHeight = 2 * hexagonRadius;
  var hexagonVerticalSpacing = hexagonHeight * 0.75;
  var hexagonHorizontalSpacing = hexagonWidth;

  var borderColor = "black"; // Farbe für den Hexagon-Rand

  function drawHexagon(x, y, fillColor) {
    context.beginPath();
    for (var i = 0; i < 6; i++) {
      var angle = (i * 60 + 30) * Math.PI / 180;
      var xPos = x + hexagonRadius * Math.cos(angle);
      var yPos = y + hexagonRadius * Math.sin(angle);
      if (i === 0) {
        context.moveTo(xPos, yPos);
      } else {
        context.lineTo(xPos, yPos);
      }
    }
    context.closePath();

    // Fülle das Hexagon mit der gewünschten Farbe
    context.fillStyle = fillColor;
    context.fill();

    // Zeichne den Hexagon-Rand in Schwarz
    context.strokeStyle = borderColor;
    context.lineWidth = 2;
    context.stroke();
  }

  function placeHexagons() {
    var canvasWidth = window.innerWidth;
    var canvasHeight = window.innerHeight;

    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    var numRows = Math.ceil(canvasHeight / hexagonVerticalSpacing);
    var numCols = Math.ceil(canvasWidth / hexagonHorizontalSpacing);

    // Berechnen Sie die Anzahl der zusätzlichen Hexagone, um die Ränder zu füllen
    var extraCols = Math.ceil((canvasWidth % hexagonHorizontalSpacing) / hexagonWidth);
    var extraRows = Math.ceil((canvasHeight % hexagonVerticalSpacing) / (hexagonHeight * 0.25));

    for (var row = 0; row < numRows + extraRows; row++) {
      for (var col = 0; col < numCols + extraCols; col++) {
        var x = col * hexagonHorizontalSpacing + (row % 2) * (hexagonWidth / 2);
        var y = row * hexagonVerticalSpacing;

        // Zufällig auswählen, welches Hexagon den Farbwechseleffekt haben soll
        var shouldAnimate = Math.random() < 0.05; // Zum Beispiel 5% der Hexagons animieren
        if (shouldAnimate) {
          animateHexagonColor(x, y);
        } else {
          var fillColor = "rgb(13, 51, 85)";
          drawHexagon(x, y, fillColor);
        }
      }
    }
  }

  window.addEventListener("resize", function () {
    placeHexagons();
  });

  placeHexagons();

  var animationSpeed = 2000; // Ändern Sie die Geschwindigkeit der Farbänderung hier (in Millisekunden)

  function animateHexagonColor(x, y) {
    var currentTime = new Date().getTime();
    var color = "rgb(" + Math.sin(currentTime / animationSpeed) * 128 + 128 + ", " + Math.sin(currentTime / animationSpeed + 2) * 128 + 128 + ", " + Math.sin(currentTime / animationSpeed + 4) * 128 + 128 + ")";

    drawHexagon(x, y, color); // Zeichnen Sie das animierte Hexagon mit der aktualisierten Farbe
    requestAnimationFrame(function () {
      animateHexagonColor(x, y);
    }); // Fortsetzen der Animation für das ausgewählte Hexagon

    setTimeout(function () {
      // Hier den Code einfügen, um die Animation auf alle benachbarten Hexagons auszudehnen.
      var neighbors = findNeighbors(x, y);
      neighbors.forEach(function (neighbor) {
        animateHexagonColor(neighbor.x, neighbor.y);
      });
    }, 5000); // 5000 Millisekunden (5 Sekunden) Verzögerung
  }

  // Funktion zum Finden der benachbarten Hexagons
  function findNeighbors(x, y) {
    var neighbors = [];
    // Hier können Sie die Logik implementieren, um die Nachbarn basierend auf den Hexagon-Koordinaten zu finden.
    // Ein Beispiel: Rechts, Links, Oben rechts, Oben links, Unten rechts, Unten links.
    neighbors.push({ x: x + hexagonHorizontalSpacing, y: y }); // Rechts
    neighbors.push({ x: x - hexagonHorizontalSpacing, y: y }); // Links

    if (row % 2 === 0) {
      neighbors.push({ x: x + hexagonWidth / 2, y: y - hexagonVerticalSpacing }); // Oben rechts
      neighbors.push({ x: x - hexagonWidth / 2, y: y - hexagonVerticalSpacing }); // Oben links
      neighbors.push({ x: x + hexagonWidth / 2, y: y + hexagonVerticalSpacing }); // Unten rechts
      neighbors.push({ x: x - hexagonWidth / 2, y: y + hexagonVerticalSpacing }); // Unten links
    } else {
      neighbors.push({ x: x + hexagonWidth / 2, y: y + hexagonVerticalSpacing }); // Unten rechts
      neighbors.push({ x: x - hexagonWidth / 2, y: y + hexagonVerticalSpacing }); // Unten links
      neighbors.push({ x: x + hexagonWidth / 2, y: y - hexagonVerticalSpacing }); // Oben rechts
      neighbors.push({ x: x - hexagonWidth / 2, y: y - hexagonVerticalSpacing }); // Oben links
    }

    return neighbors;
  }

</script>
</body>
</html>

